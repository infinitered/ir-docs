"use strict";(self.webpackChunkir_docs=self.webpackChunkir_docs||[]).push([[5134],{6421:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>a,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"ignite-cli/boilerplate/app/theme/context.ts","title":"context.ts","description":"``","source":"@site/docs/ignite-cli/boilerplate/app/theme/context.ts.md","sourceDirName":"ignite-cli/boilerplate/app/theme","slug":"/ignite-cli/boilerplate/app/theme/context.ts","permalink":"/ignite-cli/boilerplate/app/theme/context.ts","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"context.ts"},"sidebar":"Ignite","previous":{"title":"Theming Ignite Apps","permalink":"/ignite-cli/boilerplate/app/theme/Theming"},"next":{"title":"colors.ts","permalink":"/ignite-cli/boilerplate/app/theme/colors.ts"}}');var i=n(4848),s=n(8453);const r={sidebar_position:10,title:"context.ts"},l="theme/context.ts",h={},c=[{value:"<code>&lt;ThemeProvider&gt;</code>",id:"themeprovider",level:2},{value:"useAppTheme",id:"useapptheme",level:2},{value:"Properties",id:"properties",level:2},{value:"<code>navigationTheme</code>",id:"navigationtheme",level:3},{value:"<code>setThemeContextOverride</code>",id:"setthemecontextoverride",level:3},{value:"<code>theme</code>",id:"theme",level:3},{value:"<code>themeContext</code>",id:"themecontext",level:3},{value:"<code>themed</code>",id:"themed",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"themecontextts",children:"theme/context.ts"})}),"\n",(0,i.jsx)(t.h2,{id:"themeprovider",children:(0,i.jsx)(t.code,{children:"<ThemeProvider>"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"<ThemeProvider>"})," component is a context provider that wraps your app and provides access to the theme and theming tools. It should be used at the root of your application, typically in ",(0,i.jsx)(t.code,{children:"App.tsx"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:'import { ThemeProvider } from "@/theme/context"\n\nconst App = () => {\n  return <ThemeProvider>{/* Your app components go here */}</ThemeProvider>\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Anything that needs access to the ",(0,i.jsx)(t.code,{children:"useAppTheme()"})," hook should be a child of this provider."]}),"\n",(0,i.jsx)(t.h2,{id:"useapptheme",children:"useAppTheme"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"useAppTheme()"})," hook returns various properties and tools relating to theming your app. Generally, you'll only need a few properties from this hook, with the most important being ",(0,i.jsx)(t.code,{children:"theme"})," and ",(0,i.jsx)(t.code,{children:"themed"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Example usage:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:'import { View, type ViewStyle } from "react-native"\nimport { useAppTheme } from "@/theme/context"\n\nconst MyComponent = () => {\n  const {\n    // Any styles you create with the type ThemedStyle<T>\n    // must be wrapped with themed($styleName) before passing\n    // it along to the component\'s style property.\n    themed,\n    // This is the current theme object.\n    theme,\n    // themeContext is what theme you are actually using:\n    // "light" | "dark"\n    themeContext,\n  } = useAppTheme()\n\n  return (\n    <View style={themed($container)}>\n      <View style={$plainObjectStyle}>\n        {/* An Example of direct theme color usage in a component: */}\n        <View\n          style={{\n            backgroundColor: theme.colors.error,\n          }}\n        >\n          {/* This will output "light" or "dark" */}\n          <Text>{themeContext}</Text>\n        </View>\n      </View>\n    </View>\n  )\n}\n\n// This is an ignite ThemedStyle. It\'s just like a ViewStyle but\n// is wrapped with a function that will be called with a theme parameter.\nconst $container: ThemedStyle<ViewStyle> = (theme) => ({\n  // You can access theme named colors:\n  backgroundColor: theme.colors.background,\n  // Accessing the color palette is not generally recommended.\n  color: theme.colors.palette.angry500,\n  // Spacing can be changed on a per-theme basis as well.\n  paddingHorizontal: theme.spacing.small,\n})\n\n// We haven\'t abandoned plain style objects as the preferred way\n// to style your components, but it can\'t use dynamic themes.\nconst $plainObjectStyle: ViewStyle = {\n  marginBottom: 20,\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"properties",children:"Properties"}),"\n",(0,i.jsx)(t.h3,{id:"navigationtheme",children:(0,i.jsx)(t.code,{children:"navigationTheme"})}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"react-navigation"})," ",(0,i.jsx)(t.a,{href:"https://reactnavigation.org/docs/themes#built-in-themes",children:"theme object"}),". This is the same object you would pass to a ",(0,i.jsx)(t.code,{children:"NavigationContainer"})," component."]}),"\n",(0,i.jsx)(t.h3,{id:"setthemecontextoverride",children:(0,i.jsx)(t.code,{children:"setThemeContextOverride"})}),"\n",(0,i.jsx)(t.p,{children:"A function that allows you to override the theme context. This is useful for allowing users to switch between light and dark mode."}),"\n",(0,i.jsxs)(t.p,{children:["The default behavior is to use the system theme, but you can override this by calling ",(0,i.jsx)(t.code,{children:'setThemeContextOverride("light" | "dark")'}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Calling ",(0,i.jsx)(t.code,{children:"setThemeContextOverride(undefined)"})," will reset the theme to the user's system preference."]}),"\n",(0,i.jsx)(t.h3,{id:"theme",children:(0,i.jsx)(t.code,{children:"theme"})}),"\n",(0,i.jsxs)(t.p,{children:["A ",(0,i.jsx)(t.code,{children:"Theme"})," object that contains all the colors, spacing, and other theme-related properties of the current theme context. You can edit these values in the ",(0,i.jsx)(t.code,{children:"app/theme"})," folder."]}),"\n",(0,i.jsx)(t.h3,{id:"themecontext",children:(0,i.jsx)(t.code,{children:"themeContext"})}),"\n",(0,i.jsx)(t.p,{children:'A string that represents the current theme context. This will almost always be either "light" or "dark".'}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["When resetting the theme context to the system preference with ",(0,i.jsx)(t.code,{children:"setThemeContextOverride(undefined)"}),", the ",(0,i.jsx)(t.code,{children:"themeContext"})," will not be undefined. It will be the return value of ",(0,i.jsx)(t.code,{children:"react-native"}),"'s ",(0,i.jsx)(t.code,{children:"useColorScheme()"})," hook."]})}),"\n",(0,i.jsx)(t.h3,{id:"themed",children:(0,i.jsx)(t.code,{children:"themed"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"themed()"})," is a simple function with complex types. You can pass a plain style object to it, a ",(0,i.jsx)(t.code,{children:"ThemedStyle"})," function, or an array of either."]}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.p,{children:["When passing an array of styles or ",(0,i.jsx)(t.code,{children:"ThemedStyle"})," functions to ",(0,i.jsx)(t.code,{children:"themed()"}),", it will return a single style object with last properties overriding any properties previously set."]}),(0,i.jsxs)(t.p,{children:["In the example below, the last ",(0,i.jsx)(t.code,{children:"<View>"})," would be yellow even though ",(0,i.jsx)(t.code,{children:"$themedStyle"})," specifies red because the background color property was modified by a later style in the array."]})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"const $plainStyle: ViewStyle = {\n  padding: 10,\n  backgroundColor: \"black\",\n  width: 25,\n  height: 25,\n}\n\nconst $themedStyle: ThemedStyle<ViewStyle> = (theme) => ({\n  backgroundColor: theme.colors.errorBackground,\n  height: theme.spacing.xl,\n  width: theme.spacing.xl\n})\n\n<View style={$plainStyle} />\n// <View style={$themedStyle} /> // This won't work\n<View style={themed($themedStyle)} />\n// <View style={themed($plainStyle)} /> // You can, but why would you?\n<View style={themed([$themedStyle, $plainStyle])} />\n<View style={themed([\n  $themedStyle,\n  $plainStyle,\n  // A plain style object\n  { width: 7, backgroundColor: 'yellow'}\n])} />\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsxs)(t.p,{children:["Make sure you don't pass any ",(0,i.jsx)(t.code,{children:"Animated"})," styles to ",(0,i.jsx)(t.code,{children:"themed()"}),". It will not work as expected! Keep them in separate style array objects: ",(0,i.jsx)(t.code,{children:"<Animated.View style={[$animatedStyle, themed($myThemedStyle)]}>"}),"."]})})]})}function a(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var o=n(6540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);